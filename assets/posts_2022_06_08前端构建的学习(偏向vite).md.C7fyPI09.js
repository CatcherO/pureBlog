import{_ as e,c as t,o as l,ar as a,j as s}from"./chunks/framework.Dw9xXWbv.js";const g=JSON.parse('{"title":"前端工程化的学习(偏向 vite 构建工具)","description":"","frontmatter":{"title":"前端工程化的学习(偏向 vite 构建工具)","date":"2022-06-08T00:00:00.000Z","tags":["前端","工程化","vite"]},"headers":[],"relativePath":"posts/2022/06/08前端构建的学习(偏向vite).md","filePath":"posts/2022/06/08前端构建的学习(偏向vite).md","lastUpdated":1742015773000}'),n={name:"posts/2022/06/08前端构建的学习(偏向vite).md"};function h(p,i,k,o,r,d){return l(),t("div",null,i[0]||(i[0]=[a(`<h1 id="前端工程化的学习-偏向-vite-构建工具" tabindex="-1">前端工程化的学习(偏向 vite 构建工具) <a class="header-anchor" href="#前端工程化的学习-偏向-vite-构建工具" aria-label="Permalink to &quot;前端工程化的学习(偏向 vite 构建工具)&quot;">​</a></h1><blockquote><p>✨文章摘要（AI生成）</p></blockquote><p>笔者在学习前端工程化时，决定深入了解 Vite 构建工具，尤其是在项目中需要封装组件的过程中，感受到脚手架的缺乏带来的不便。Vite 的优势在于其开发环境中基于 ES 模块的按需加载，极大提升了启动速度，尤其在处理大型项目时表现出色。与 Webpack 相比，Vite 更关注开发体验，而 Webpack 则强调兼容性。</p><p>笔者总结了 Vite 的几个重要特性，如依赖预构建、路径补全、以及对 CSS 和静态资源的处理方式。同时，笔者提到构建优化的重要性，包括体积优化和分包策略，以提高浏览器的缓存效率。整体而言，Vite 的设计理念使得前端开发更为高效，帮助开发者更专注于代码编写而非运行细节。</p><hr><blockquote><p>好早就听说了 vite，也早就简单的使用并了解了一点，之前在公司实习团队也正在迁移 webpack 的项目到 vite，但我自己却一直没有深入，毕竟还是初级前端工程师，功力还欠缺很多，但最近封装了一个小组件，整个项目不使用脚手架挺难受的，到处参考别人的代码希望能找到组件开发的最佳实践，整个过程举步维艰，所以开始先从 vite 入手学习一下前端工程化相关的东西了...</p></blockquote><h2 id="为什么需要构建工具" tabindex="-1">为什么需要构建工具 <a class="header-anchor" href="#为什么需要构建工具" aria-label="Permalink to &quot;为什么需要构建工具&quot;">​</a></h2><p>摘抄一段<code>vite</code>官网对<code>打包</code>的描述：</p><blockquote><p>使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件</p></blockquote><p>现阶段我们基本都不会直接编写可以浏览器上运行的文件，更多的是使用各种新的框架（Vue/React）、语法（TypeScript/less/sass），用这些工具编写出来的代码时不能直接在浏览器上直接运行的，我们需要每次都手动使用不同的解释器/编译器去将用高级语法编写的代码转换为能在浏览器中运行的代码： <img src="https://oss.justin3go.com/blogs/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.png" alt=""><strong>所以简单理解构建工具（打包工具）要做的就是这样一件事</strong>：将这条工具链内置，面向开发者透明，避免开发者每次查看效果都要重复机械化地输入不同的命令，除此之外，构建工具还可以使用各种优化工具优化最终生成的文件。 一般来说，一个构建工具会有以下功能：</p><ul><li><strong>模块化支持</strong>：兼容多种模块化规范写法，支持从<code>node_modules</code>中引入代码（浏览器本身只识别路径方式的模块导入，<code>imoprt { forEach } from &#39;loadsh&#39;</code>这样直接以名字导入需构建工具识别）</li><li><strong>框架编译/语法转换</strong>：如：<code>tsc-&gt;lessc-&gt;vueComplier</code></li><li><strong>构建产物性能优化</strong>：文件打包、代码压缩、code splitting、tree shaking...</li><li><strong>开发体验优化</strong>：hot module replacement、跨域解决等...</li><li>... 总的来说，构建工具让我们开发人员可以更加关注代码的编写，而非代码的运行。</li></ul><h2 id="五花八门的构建工具" tabindex="-1">五花八门的构建工具 <a class="header-anchor" href="#五花八门的构建工具" aria-label="Permalink to &quot;五花八门的构建工具&quot;">​</a></h2><p>市面上常见的构建工具有如下（这里简单说一下各种构建工具的特点，具体展开就太多了，大家感兴趣可以直接去官网看看）：</p><ul><li>grunt：基于配置驱动的，开发者需要做的就是了解各种插件的功能，然后把配置整合到 Gruntfile.js 中，然后就可以自动处理一些需要反复重复的任务，例如代码压缩、编译、单元测试、linting 等工作，配置复杂度较高且 IO 操作较多。</li><li>gulp：Gulp 最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递。这使得它本身被设计的非常简单，但却拥有强大的功能，既可以单独完成构建，也可以和其他工具搭配使用</li><li>webpack：最主流的打包构建工具，兼容覆盖基本所有场景，前端工程化的核心，但相应带来的缺点就是配置繁琐</li><li>rollup：由于 webpack 配置繁琐，对于小型项目开发者较不友好，他们更倾向于 rollup。其配置简单，易于上手，成为了目前最流行的 JS 库打包工具</li><li>esbuild：使用 go 语言并大量使用了其高并发的特性，速度极快。不过目前 Esbuild 还很年轻，没有达到 1.0 版本，并且其打包构建与 Rollup 类似更关注于 JS 本身，所以并不适合单独使用在前端项目的生产环境之中</li><li>parcel：...</li><li>...</li><li>vite：开发环境基于 esmodule 规范按需加载，速度极快，具有极佳的开发体验，生产环境底层调用 rollup，接下来主要介绍 webpack 与 vite 之间的一个对比。</li></ul><p>其实官网介绍 vite 的优势已经非常详细了，我自身也没有额外的理解，这里就直接摘要一段官网的话：</p><blockquote><p>当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈，Vite 以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noreferrer">原生 ESM</a> 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。</p></blockquote><p>再贴两张大家可能已经很熟的对比图： <img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221103210037.png" alt=""> 相信大家看了上述官网的摘要差不多已经明白为什么 vite 在开发环境下启动速度非常快的原因了，主要就是使用了浏览器原生支持的<code>esmodule</code>规范，当然还少不了 vite 本身在这之上做的一些优化，比如<a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html" target="_blank" rel="noreferrer">依赖预构建</a> 我在一篇文章中看到过这样一个问题：这个思路既然能解决开发启动速度上的问题，为什么 webpack 不能支持呢？ 答：</p><ul><li>webpack 的设计理念就是大而全，它需要兼容不同的模块化，我们的工程既有可能跑在浏览器端，也有可能跑在服务端，所以 webpack 会将不同的模块化规范转换为独有的一个函数<code>webpack_require</code>进行处理，为了做到这一点，它必须一开始就要统一编译转换模块化代码，也就意味着它需要将所有的依赖全部读取一遍；</li><li>而我们在使用 vite 项目的时候，就只能使用<code>esmodule</code>规范，但项目的依赖仍然可能使用了不同的模块规范，vite 会在依赖预构建中处理这一步，将依赖树转换为单个模块并缓存在<code>/node_modules/.vite</code>下方便浏览器按需加载，将打包的部分工作交给了浏览器执行，优化了开发体验。而构建交给了<code>rollup</code>同样会兼容各种模块化规范...</li></ul><p>总结：<strong>webpack 更多的关注兼容性，而 vite 关注浏览器端的开发体验</strong>，侧重点不一样</p><h2 id="vite-处理细节" tabindex="-1">vite 处理细节 <a class="header-anchor" href="#vite-处理细节" aria-label="Permalink to &quot;vite 处理细节&quot;">​</a></h2><blockquote><p>自身对前端工程化的理解也比较浅，从 vite 官网文档中可以学到不少前端工程化相关的知识，知识点总结至 vite 官网，<a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noreferrer">快速入口</a></p></blockquote><h3 id="_1-导入路径补全" tabindex="-1">1. 导入路径补全 <a class="header-anchor" href="#_1-导入路径补全" aria-label="Permalink to &quot;1. 导入路径补全&quot;">​</a></h3><p>在处理的过程中如果说看到了有非绝对路径或者相对路径的引用, 他则会尝试开启路径补全：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;lodash&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 补全前，浏览器并不认识这种裸模块导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/node_modules/.vite/lodash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 补全后，使用依赖预构建处理后的结果</span></span></code></pre></div><h3 id="_2-依赖预构建" tabindex="-1">2. 依赖预构建 <a class="header-anchor" href="#_2-依赖预构建" aria-label="Permalink to &quot;2. 依赖预构建&quot;">​</a></h3><p>主要就是为了解网络多包传输的性能问题，官网原话：</p><blockquote><p>一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，<a href="https://unpkg.com/browse/lodash-es/" target="_blank" rel="noreferrer"><code>lodash-es</code> 有超过 600 个内置模块</a>！当我们执行 <code>import { debounce } from &#39;lodash-es&#39;</code> 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。</p></blockquote><blockquote><p>通过<strong>预构建 <code>lodash-es</code> 成为一个模块</strong>，我们就只需要一个 HTTP 请求了！</p></blockquote><p>重写前：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.js </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./a.js&quot;</span></span></code></pre></div><p>vite 重写以后：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>顺便解决了以下两个问题：</p><ul><li>不同的第三方包会有不同的导出格式，Vite 会将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM</li><li>对路径的处理上可以直接使用.vite/deps, 方便路径重写</li></ul><blockquote><p>其他：构建这一步由 <a href="http://esbuild.github.io/" target="_blank" rel="noreferrer">esbuild</a> 执行，这使得 Vite 的冷启动时间比任何基于 JavaScript 的打包器都要快得多</p></blockquote><p>注意：这里都是指的开发环境，生产环境会交给 rollup 去执行</p><h3 id="_3-vite-与-ts" tabindex="-1">3. vite 与 ts <a class="header-anchor" href="#_3-vite-与-ts" aria-label="Permalink to &quot;3. vite 与 ts&quot;">​</a></h3><p>vite 他天生就对 ts 支持非常良好, 因为 vite 在开发时态是基于 esbuild, 而 esbuild 是天生支持对 ts 文件的转换的<a href="https://cn.vitejs.dev/guide/features.html#typescript" target="_blank" rel="noreferrer">快速入口</a></p><h3 id="_4-环境变量" tabindex="-1">4. 环境变量 <a class="header-anchor" href="#_4-环境变量" aria-label="Permalink to &quot;4. 环境变量&quot;">​</a></h3><p>一个产品可能要经过如下环境：</p><ol><li><p>开发环境</p></li><li><p>测试环境</p></li><li><p>预发布环境</p></li><li><p>灰度环境</p></li><li><p>生产环境 不同的环境使用的数据应该是隔离的，或者是经过处理的，比如小流量环境，很显然，不同环境在一些密钥上的设置上是不同的，环境变量在这时候就尤为重要了，vite 中内置了 dotenv 对环境变量进行处理： dotenv 会自动读取.env 文件, 并解析这个文件中的对应环境变量 并将其注入到 process 对象下(但是 vite 考虑到和其他配置的一些冲突问题, 他不会直接注入到 process 对象下) 配置：</p><p>.env # 所有情况下都会加载 .env.local # 所有情况下都会加载，但会被 git 忽略 .env.[mode] # 只在指定模式下加载 .env.[mode].local # 只在指定模式下加载，但会被 git 忽略 然后文件里使用<code>VITE</code>前缀的命名变量<code>VITE_SOME_KEY=123</code>，可以在<code>vite.config.ts</code>中配置<code>envPrefix: &quot;ENV_&quot;</code>修改这个前缀 使用：</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VITE_SOME_KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 123</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_PASSWORD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span></code></pre></div><p>其他：为什么 vite.config.js 可以书写成 esmodule 的形式(vite 明明是运行在服务端的), 这是因为 vite 他在读取这个 vite.config.js 的时候会率先 node 去解析文件语法, 如果发现你是 esmodule 规范会直接将你的 esmodule 规范进行替换变成 commonjs 规范</p><h3 id="_5-vite-对-css-的处理" tabindex="-1">5. vite 对 css 的处理 <a class="header-anchor" href="#_5-vite-对-css-的处理" aria-label="Permalink to &quot;5. vite 对 css 的处理&quot;">​</a></h3><h4 id="基本流程-1-vite-在读取到-main-js-中引用到了-index-css" tabindex="-1">基本流程：1. vite 在读取到 main.js 中引用到了 Index.css <a class="header-anchor" href="#基本流程-1-vite-在读取到-main-js-中引用到了-index-css" aria-label="Permalink to &quot;基本流程：1. vite 在读取到 main.js 中引用到了 Index.css&quot;">​</a></h4><ol start="2"><li>直接去使用 fs 模块去读取 index.css 中文件内容</li><li>直接创建一个 style 标签, 将 index.css 中文件内容直接 copy 进 style 标签里</li><li>将 style 标签插入到 index.html 的 head 中</li><li>将该 css 文件中的内容直接替换为 js 脚本(方便热更新或者 css 模块化), 同时设置 Content-Type 为 js 从而让浏览器以 JS 脚本的形式来执行该 css 后缀的文件 <img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221103081114.png" style="zoom:80%;"></li></ol><h4 id="处理重复类名" tabindex="-1">处理重复类名 <a class="header-anchor" href="#处理重复类名" aria-label="Permalink to &quot;处理重复类名&quot;">​</a></h4><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221103081823.png" style="zoom:80%;"><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221103081933.png" style="zoom:80%;"> 全部都是基于 node `,51),s("ol",null,[s("li",null,"module.css (module 是一种约定, 表示需要开启 css 模块化)"),s("li",null,"他会将你的所有类名进行一定规则的替换（将 footer 替换成 _footer_i22st_1）"),s("li",{"footer:":"",_footer_i22st_1:""},"同时创建一个映射对象"),s("li",null,"将替换过后的内容塞进 style 标签里然后放入到 head 标签中 (能够读到 index.html 的文件内容)"),s("li",null,"将 componentA.module.css 内容进行全部抹除, 替换成 JS 脚本"),s("li",null,"将创建的映射对象在脚本中进行默认导出")],-1),a(`<h4 id="config-参考" tabindex="-1">config 参考 <a class="header-anchor" href="#config-参考" aria-label="Permalink to &quot;config 参考&quot;">​</a></h4><p><a href="https://cn.vitejs.dev/config/shared-options.html#css-modules" target="_blank" rel="noreferrer">快速入口</a></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 摘自 https://github.com/passerecho/vite-</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对 css 的行为进行配置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // modules 配置最终会丢给 postcss modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        modules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是对 css 模块化的默认行为进行覆盖</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            localsConvention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;camelCaseOnly&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改生成的配置对象的 key 的展示形式(驼峰还是中划线形式)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            scopeBehaviour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;local&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置当前的模块化行为是模块化还是全局化 (有 hash 就是开启了模块化的一个标志, 因为他可以保证产生不同的 hash 值来控制我们的样式类名不被覆盖)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // generateScopedName: &quot;[name]_[local]_[hash:5]&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // https://github.com/webpack/loader-utils#interpolatename</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // generateScopedName: (name, filename, css) =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // name -&gt; 代表的是你此刻 css 文件中的类名</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // filename -&gt; 是你当前 css 文件的绝对路径</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // css -&gt; 给的就是你当前样式</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //     console.log(&quot;name&quot;, name, &quot;filename&quot;, filename, &quot;css&quot;, css);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这一行会输出在哪？？？ 输出在 node</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 配置成函数以后, 返回值就决定了他最终显示的类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //     return \`\${name}_\${Math.random().toString(36).substr(3, 8) }\`;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            hashPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成 hash 会根据你的类名 + 一些其他的字符串(文件名 + 他内部随机生成一个字符串)去进行生成, 如果你想要你生成 hash 更加的独特一点, 你可以配置 hashPrefix, 你配置的这个字符串会参与到最终的 hash 生成, （hash: 只要你的字符串有一个字不一样, 那么生成的 hash 就完全不一样, 但是只要你的字符串完全一样, 生成的 hash 就会一样）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            globalModulePaths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./componentB.module.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 代表你不想参与到 css 模块化的路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        preprocessorOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// key + config key 代表预处理器的名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            less</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 整个的配置对象都会最终给到 less 的执行参数（全局参数）中去</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 在 webpack 里就给 less-loader 去配置就好了</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                math</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;always&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                globalVars</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局变量</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    mainColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        devSourcemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span></code></pre></div><h3 id="_6-静态资源" tabindex="-1">6. 静态资源 <a class="header-anchor" href="#_6-静态资源" aria-label="Permalink to &quot;6. 静态资源&quot;">​</a></h3><p>服务时引入一个静态资源会返回解析后的公共路径：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import imgUrl from &#39;./img.png&#39;</span></span>
<span class="line"><span>document.getElementById(&#39;hero-img&#39;).src = imgUrl</span></span></code></pre></div><p>例如，<code>imgUrl</code> 在开发时会是 <code>/img.png</code>，在生产构建后会是 <code>/assets/img.2d8efhg.png</code>。</p><p>行为类似于 Webpack 的 <code>file-loader</code>。区别在于导入既可以使用绝对公共路径（基于开发期间的项目根路径），也可以使用相对路径。</p><h4 id="为什么要使用-hash" tabindex="-1">为什么要使用 hash <a class="header-anchor" href="#为什么要使用-hash" aria-label="Permalink to &quot;为什么要使用 hash&quot;">​</a></h4><p>浏览器是有一个缓存机制 静态资源名字只要不改, 那么他就会直接用缓存的 刷新页面--&gt; 请求的名字是不是同一个 --&gt; 读取缓存 --&gt; 所以我们要尽量去避免名字一致(每次开发完新代码并构建打包时)</p><h4 id="_1-显式-url-引入" tabindex="-1">1. 显式 URL 引入 <a class="header-anchor" href="#_1-显式-url-引入" aria-label="Permalink to &quot;1. 显式 URL 引入&quot;">​</a></h4><p>未被包含在内部列表或 <code>assetsInclude</code> 中的资源，可以使用 <code>?url</code> 后缀显式导入为一个 URL。这十分有用，例如，要导入 <a href="https://houdini.how/usage" target="_blank" rel="noreferrer">Houdini Paint Worklets</a> 时：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> workletURL </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;extra-scalloped-border/worklet.js?url&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CSS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.paintWorklet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(workletURL)</span></span></code></pre></div><h4 id="_2-将资源引入为字符串" tabindex="-1">2. 将资源引入为字符串 <a class="header-anchor" href="#_2-将资源引入为字符串" aria-label="Permalink to &quot;2. 将资源引入为字符串&quot;">​</a></h4><p>资源可以使用 <code>?raw</code> 后缀声明作为字符串引入。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shaderString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./shader.glsl?raw&#39;</span></span></code></pre></div><p>比如 svg 文件如果我们以 url 的方式导入文件，则相当于导入一张图片，只能对其进行图片的相关操作，如果我们想要对其进行 svg 相关的操作，我们则需要使用<code>?raw</code>的方式导入：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> svgIcon </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./assets/svgs/fullScreen.svg?url&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这种是以图片的方式加载 svg，无其他特殊操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> svgRaw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./assets/svgs/fullScreen.svg?raw&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载 svg 的源文件，这种方式的加载可以做到修改 svg 的颜色等操作</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;svgIcon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, svgIcon, svgRaw);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> svgRaw;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> svgElement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;svg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">svgElement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmouseenter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 不是去改他的 background 也不是 color</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 而是 fill 属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.style.fill </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一种使用 svg 的方式</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const img = document.createElement(&quot;img&quot;);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// img.src = svgIcon;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// document.body.appendChild(img);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二种加载 svg 的方式</span></span></code></pre></div><h4 id="_3-导入脚本作为-worker" tabindex="-1">3. 导入脚本作为 Worker <a class="header-anchor" href="#_3-导入脚本作为-worker" aria-label="Permalink to &quot;3. 导入脚本作为 Worker&quot;">​</a></h4><p>脚本可以通过 <code>?worker</code> 或 <code>?sharedworker</code> 后缀导入为 web worker。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在生产构建中将会分离出 chunk</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./shader.js?worker&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sharedworker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SharedWorker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./shader.js?sharedworker&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sharedWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 内联为 base64 字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> InlineWorker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./shader.js?worker&amp;inline&#39;</span></span></code></pre></div><p><a href="https://cn.vitejs.dev/guide/assets.html" target="_blank" rel="noreferrer">快速入口</a></p><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><ol><li>代码逻辑上的优化，如： <ol><li>使用<code>lodash</code>工具中的防抖、节流而非自己编写；数组数据量大时，也可以使用<code>lodash</code>中的<code>forEach</code>方法等等</li><li><code>for(let i = 0; i &lt; arr.length; i++){}</code>替换为<code>for(let i = 0, len = arr.length; i &lt; len; i++)</code>这样只用通过作用域链获取一次父作用域中的<code>arr</code>变量</li><li>...</li></ol></li><li>构建优化（构建工具关注的事）：体积优化-&gt;压缩、treeshaking、图片资源压缩、cdn 加载、分包...</li><li>...</li></ol><p><strong>其中分包知识我第一次接触到，这里记录一下：</strong> 主要是为了配合浏览器中的缓存策略</p><ul><li>假设这样一个场景，我们使用<code>lodash</code>中的<code>forEach</code>函数编写了<code>console(&#39;1&#39;)</code>，最终打包后的代码如果不分包则会将<code>lodash</code>中的相关实现和<code>console(&#39;1&#39;)</code>合并为一个文件传给浏览器；</li><li>而我们的业务代码经常变化，比如<code>console(&#39;1&#39;)</code>--&gt;<code>console(&#39;2&#39;)</code>这时候我们仍然需要将<code>lodash</code>中的相关实现和<code>console(&#39;1&#39;)</code>合并为一个文件传给浏览器；</li><li>但显然<code>lodash</code>中的代码实现并没有更改，浏览器直接使用以前的就可以了</li><li>所以分包就是把一些不会经常更新的文件，进行单独打包处理为一个文件，<a href="https://cn.vitejs.dev/guide/build.html#chunking-strategy" target="_blank" rel="noreferrer">配置参考</a><img src="https://oss.justin3go.com/blogs/%E5%88%86%E5%8C%85%E4%BC%98%E5%8A%BF.png" alt=""></li></ul><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>前端工程化我也是最近开始学习，如有理解错误希望各位大佬不吝赐教</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://cn.vitejs.dev/" target="_blank" rel="noreferrer">https://cn.vitejs.dev/</a></li><li><a href="https://segmentfault.com/a/1190000040135876" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000040135876</a></li><li><a href="https://juejin.cn/post/7085613927249215525#heading-15" target="_blank" rel="noreferrer">https://juejin.cn/post/7085613927249215525#heading-15</a></li><li><a href="https://github.com/passerecho/vite-" target="_blank" rel="noreferrer">https://github.com/passerecho/vite-</a></li><li><a href="https://css-tricks.com/comparing-the-new-generation-of-build-tools/" target="_blank" rel="noreferrer">https://css-tricks.com/comparing-the-new-generation-of-build-tools/</a></li><li><a href="https://juejin.cn/post/7085613927249215525#heading-2" target="_blank" rel="noreferrer">https://juejin.cn/post/7085613927249215525#heading-2</a></li></ul>`,32)]))}const E=e(n,[["render",h]]);export{g as __pageData,E as default};
