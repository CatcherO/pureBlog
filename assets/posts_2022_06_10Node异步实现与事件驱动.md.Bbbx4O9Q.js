import{_ as l,c as i,o,ar as s,j as e,a}from"./chunks/framework.Dw9xXWbv.js";const y=JSON.parse('{"title":"Node 异步实现与事件驱动","description":"","frontmatter":{"title":"Node 异步实现与事件驱动","date":"2022-06-10T00:00:00.000Z","tags":["Node.js","异步","事件驱动"]},"headers":[],"relativePath":"posts/2022/06/10Node异步实现与事件驱动.md","filePath":"posts/2022/06/10Node异步实现与事件驱动.md","lastUpdated":1742015773000}'),n={name:"posts/2022/06/10Node异步实现与事件驱动.md"},d={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},p={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.682ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3837.6 1000","aria-hidden":"true"},r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},T={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.682ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3837.6 1000","aria-hidden":"true"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},c={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.618ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2041 1000","aria-hidden":"true"};function Q(k,t,m,u,g,E){return o(),i("div",null,[t[15]||(t[15]=s('<h1 id="node-异步实现与事件驱动" tabindex="-1">Node 异步实现与事件驱动 <a class="header-anchor" href="#node-异步实现与事件驱动" aria-label="Permalink to &quot;Node 异步实现与事件驱动&quot;">​</a></h1><blockquote><p>✨文章摘要（AI生成）</p></blockquote><p>在重新阅读《深入浅出 NodeJS》的过程中，我深入理解了 Node 的异步实现与事件驱动特性。Node 通过单线程结合异步 I/O，避免了多线程带来的复杂性和性能开销。它利用非阻塞 I/O 与事件循环机制，允许 CPU 在等待 I/O 操作时处理其他任务，从而提高了资源利用率。</p><p>我学习了阻塞与非阻塞 I/O 的区别，以及不同轮询方法（如<code>select</code>、<code>poll</code>、<code>epoll</code>等）的优缺点。Node 内部虽是多线程处理 I/O，但开发者的 JavaScript 代码仍在单线程中运行。此外，<code>setTimeout</code>、<code>setImmediate</code>和<code>process.nextTick</code>等 API 的实现原理与异步 I/O 相似，但不需要线程池的介入。</p><p>通过事件驱动模型，Node 能够高效地处理网络请求，解决了如雪崩问题等性能挑战。这一切都让我对 Node 的异步处理有了更深的理解。</p><hr><blockquote><p>这是重新阅读《深入浅出 NodeJS》的相关笔记，这次阅读发现自己依旧收获很多，而第一次阅读的东西也差不多忘记完了，所以想着这次过一遍脑子，用自己的理解输出一下，方便记忆以及以后回忆...</p></blockquote><h2 id="node-的特点" tabindex="-1">Node 的特点 <a class="header-anchor" href="#node-的特点" aria-label="Permalink to &quot;Node 的特点&quot;">​</a></h2><blockquote><p>计算机中的一些任务一般可以划分为两个类别，一个类别叫做 IO 密集型，一个叫做计算密集型；对于计算密集型的任务，只能不断榨干 CPU 的性能，但是对于 IO 密集型的任务来说，理想情况下却并不需要，只需要通知 IO 设备进行处理，过一段时间再来拿去数据就好了。</p></blockquote><p>对于某些场景有一些互不相关的任务需要完成，现行的主流方法有如下两种：</p><ul><li>多线程并行完成：多线程的代价在于创建线程和执行线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题；</li><li>单线程顺序执行：易于表达，但串行执行的缺点在于性能，任意一个略慢的任务都会导致后续代码被组设</li></ul><p><code>node</code>在两者之前给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步 IO，让单线程远离阻塞，以更好地使用 CPU</p><p><img src="https://oss.justin3go.com/blogs/%E5%BC%82%E6%AD%A5IO%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h2 id="node-是如何实现异步的" tabindex="-1">Node 是如何实现异步的 <a class="header-anchor" href="#node-是如何实现异步的" aria-label="Permalink to &quot;Node 是如何实现异步的&quot;">​</a></h2><blockquote><p>刚才讲了<code>node</code>在多任务处理的方案，但是<code>node</code>内部想要实现却并不容易，下面介绍操作系统的几个概念，方面后续大家更好理解，后面再讲一讲异步的实现以及 node 的事件循环机制：</p></blockquote><h3 id="阻塞-io-与非阻塞-io" tabindex="-1">阻塞 IO 与非阻塞 IO <a class="header-anchor" href="#阻塞-io-与非阻塞-io" aria-label="Permalink to &quot;阻塞 IO 与非阻塞 IO&quot;">​</a></h3><ul><li>阻塞 IO：应用层面发起 IO 调用之后，就一直等待数据，等操作系统内核层面完成所有操作后，调用才结束；</li></ul><blockquote><p>操作系统中一切皆文件，输入输出设备同样被抽象为了文件，内核在执行 IO 操作时，通过<strong>文件描述符</strong>进行管理</p></blockquote><ul><li>非阻塞 IO：差别为调用后立即返回一个文件描述符，并不等待，这时候 CPU 的时间片就可以用来处理其他事务，之后可以通过这个文件描述符进行结果的获取；</li></ul><p>非阻塞 IO 存在的一些问题：虽然其让 CPU 的利用率提高了，但是由于立即返回的是一个文件描述符，我们并不知道 IO 操作什么时候完成，为了确认状态变更，我们只能作轮询操作</p><h3 id="不同的轮询方法" tabindex="-1">不同的轮询方法 <a class="header-anchor" href="#不同的轮询方法" aria-label="Permalink to &quot;不同的轮询方法&quot;">​</a></h3><ul><li><code>read</code> ：最原始、性能最低的一种，通过<strong>重复检查 IO 状态</strong>来完成完整数据的获取</li><li><code>select</code>：通过对<strong>文件描述符上的事件状态</strong>来进行判断，相对来说消耗更少；缺点就是它采用了一个 1024 长度的数组来存储状态，所以它最多可以同时检查 1024 个文件描述符</li><li><code>poll</code>：由于<code>select</code>的限制，<code>poll</code>改进为链表的存储方式，其他的基本都一致；但是当文件描述符较多的时候，它的性能还是非常低下的</li><li><code>eopll</code>：该方案是<code>linux</code>下效率最高的 IO 事件通知机制，在进入轮询的时候如果没有检查 IO 事件，将会进行休眠，直到事件发生将它唤醒</li><li><code>kqueue</code>：与<code>epoll</code>类似，不过仅在 FreeBSD 系统下存在</li></ul><p>尽管<code>epoll</code>利用了事件来降低对 CPU 的耗用，但休眠期间 CPU 几乎是闲置的；我们期待的异步 IO 应该是应用程序发起非阻塞调用，无须通过遍历或事件唤醒等方式轮询，可以直接处理下一个任务，只需 IO 完成后通过信号或者回调将数据传递给应用程序即可。</p><blockquote><p>linux 下还有中 AIO 方式就是通过信号或回调来传递数据的，不过只有 Linux 有，并且有限制无法利用系统缓存</p></blockquote><h3 id="node-中对于异步-io-的实现" tabindex="-1">node 中对于异步 IO 的实现 <a class="header-anchor" href="#node-中对于异步-io-的实现" aria-label="Permalink to &quot;node 中对于异步 IO 的实现&quot;">​</a></h3><p>先说结论，<code>node</code>对异步 IO 的实现是通过多线程实现的。可能会混淆的地方就是<code>node</code>内部虽然是多线程的，但是我们程序员开发的<code>JavaScript</code>代码却仅仅是运行在单线程上的。</p><p><code>node</code>通过部分线程进行阻塞 IO 或者非阻塞 IO 加上轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 IO 得到的数据进行传递，这就轻松实现了异步 IO 的模拟。</p><p><img src="https://oss.justin3go.com/blogs/node%E5%BC%82%E6%AD%A5IO.png" alt=""></p><p>除了异步 IO，计算机中的其他资源也适用，因为 linux 中一切皆文件，磁盘、硬件、套接字等几乎所有计算机资源都被抽象为了文件，接下来介绍对计算机资源的调用都以 IO 为例子。</p><h3 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h3><p>在进程启动时，<code>node</code>便会创建一个类似与<code>while(true)</code>的循环，每执行一次循环体的过程我们成为<code>Tick</code>；</p><p>下方为<code>node</code>中事件循环流程图：</p><p><img src="https://oss.justin3go.com/blogs/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p><p>很简单的一张图，简单解释一下：就是每次都从 IO 观察者里面获取执行完成的事件（是个请求对象，简单理解就是包含了请求中产生的一些数据），然后没有回调函数的话就继续取出下一个事件（请求对象），有回调就执行回调函数</p><h2 id="异步-io-细节" tabindex="-1">异步 IO 细节 <a class="header-anchor" href="#异步-io-细节" aria-label="Permalink to &quot;异步 IO 细节&quot;">​</a></h2><p><img src="https://oss.justin3go.com/blogs/%E6%95%B4%E4%B8%AA%E5%BC%82%E6%AD%A5IO%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt=""></p><blockquote><p>注：不同平台有不同的细节实现，这张图隐藏了相关平台兼容细节，比如 windows 下使用 IOCP 中的<code>PostQueuedCompletionStatus()</code>提交执行状态，通过<code>GetQueuedCompletionStatus</code>获取执行完成的请求，并且 IOCP 内部实现了线程池的细节，而 linux 等平台通过<code>eopll</code>实现这个过程，并在<code>libuv</code>下自实现了线程池</p></blockquote><h2 id="settimtout与setinterval" tabindex="-1"><code>setTimtout</code>与<code>setInterval</code> <a class="header-anchor" href="#settimtout与setinterval" aria-label="Permalink to &quot;`setTimtout`与`setInterval`&quot;">​</a></h2><p>除了 IO 等计算机资源需要异步调用之外，<code>node</code>本身还存在一些与异步 IO 无关的一些<strong>其他异步 API</strong>：</p><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>process.nextTick</code></li></ul><blockquote><p>该小节先讲解前面两个 api</p></blockquote><p>它们的实现原理与异步 IO 比较类似，<strong>只是不需要 IO 线程池的参与</strong>：</p><ul><li><code>setTimtout</code>与<code>setInterval</code>创建的定时器会被插入到定时器观察者内部的一个红黑树中</li><li>每次<code>tick</code>执行的时候，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间</li><li>如果超过，就将这个事件（请求对象）推入到事件队列中，在事件循环中执行其中的回调函数</li></ul>',43)),e("blockquote",null,[e("p",null,[t[2]||(t[2]=a("红黑树：这里简单提一下，就是一种特殊化的平衡二叉树，可以自平衡，查找效率基本上就是该二叉树的深度了")),e("mjx-container",d,[(o(),i("svg",p,t[0]||(t[0]=[s('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z" style="stroke-width:3;"></path></g><g data-mml-node="msub" transform="translate(1935,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mi" transform="translate(2848.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(3448.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g>',1)]))),t[1]||(t[1]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mi",null,"l"),e("mi",null,"o"),e("msub",null,[e("mi",null,"g"),e("mn",null,"2")]),e("mi",null,"n"),e("mo",{stretchy:"false"},")")])],-1))])])]),t[16]||(t[16]=s('<p>你有考虑过这个问题吗，为什么定时器不需要线程池的参与了呢，如果你理解了之前章节对于异步 IO 实现原理的话，相信你应该能解释出来，这里简单说说原因来加深记忆：</p><p><strong><code>node</code>中的 IO 线程池是用来调用 IO 并等待数据返回（看具体实现）的一种方式，它使<code>JavaScript</code>单线程得以异步调用 IO，并且不需要等待 IO 执行完成（因为是 IO 线程池做了），并且能获取到最终的数据（通过观察者模式：IO 观察者从线程池获取执行完成的事件，事件循环机制执行后续的回调函数）</strong></p><p>上述这段话可能有点简略，如果你还不明白，可以看下之前的那几种图~</p><h2 id="process-nexttick与setimmediate" tabindex="-1"><code>process.nextTick</code>与<code>setImmediate</code> <a class="header-anchor" href="#process-nexttick与setimmediate" aria-label="Permalink to &quot;`process.nextTick`与`setImmediate`&quot;">​</a></h2><p>这两个函数都是代表立即异步执行一个函数，那为什么不用<code>setTimeout(() =&gt; { ... }, 0)</code>来完成呢？</p><ul><li>定时器精度不够</li><li>定时器使用红黑树来创建定时器对象和迭代操作，浪费性能</li><li>即<code>process.nextTick</code>更加轻量</li></ul>',6)),e("p",null,[t[7]||(t[7]=a("轻量具体来说：我们在每次调用")),t[8]||(t[8]=e("code",null,"process.nextTick",-1)),t[9]||(t[9]=a("的时候，只会将回调函数放入队列中，在下一轮")),t[10]||(t[10]=e("code",null,"Tick",-1)),t[11]||(t[11]=a("时取出执行。定时器中采用红黑树的方式时")),e("mjx-container",r,[(o(),i("svg",T,t[3]||(t[3]=[s('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z" style="stroke-width:3;"></path></g><g data-mml-node="msub" transform="translate(1935,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mi" transform="translate(2848.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(3448.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g>',1)]))),t[4]||(t[4]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mi",null,"l"),e("mi",null,"o"),e("msub",null,[e("mi",null,"g"),e("mn",null,"2")]),e("mi",null,"n"),e("mo",{stretchy:"false"},")")])],-1))]),t[12]||(t[12]=a("，")),t[13]||(t[13]=e("code",null,"nextTick",-1)),t[14]||(t[14]=a("为")),e("mjx-container",h,[(o(),i("svg",c,t[5]||(t[5]=[s('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g>',1)]))),t[6]||(t[6]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mn",null,"1"),e("mo",{stretchy:"false"},")")])],-1))])]),t[17]||(t[17]=s(`<p>那<code>process.nextTick</code>与<code>setImmediate</code>又有什么区别呢？毕竟它们都是将回调函数立即异步执行</p><ul><li><code>process.nextTick</code>的回调执行优先级高于<code>setImmediate</code></li><li><code>process.nextTick</code>的回调函数保存在一个数组中，每轮事件循环下全部执行，<code>setImmediate</code>的结果则是保存在链表中，每轮循环按序执行第一个回调</li></ul><p>注意：之所以<code>process.nextTick</code>的回调执行优先级高于<code>setImmediate</code>，因为事件循环对观察者的检查是有顺序的，<code>process.nextTick</code>属于<code>idle</code>观察者，<code>setImmediate</code>属于<code>check</code>观察者。<code>iedl 观察者 &gt; IO 观察者 &gt; check 观察者</code></p><h2 id="高性能服务器" tabindex="-1">高性能服务器 <a class="header-anchor" href="#高性能服务器" aria-label="Permalink to &quot;高性能服务器&quot;">​</a></h2><blockquote><p>对于网络套接字的处理，<code>node</code>也应用到了异步 IO，网络套接字上侦听到的请求都会形成事件交给 IO 观察者，事件循环会不停地处理这些网络 IO 事件，如果我们在<code>JavaScrpt</code>层面上有传入对应的回调函数，这些回调函数就会在事件循环中执行（处理这些网络请求）</p></blockquote><p>常见的服务器模型：</p><ul><li>同步式</li><li>每进程--&gt;每请求</li><li>每线程--&gt;每请求</li></ul><p>而<code>node</code>采用的是事件驱动的方式处理这些请求，无需对每个请求创建额外的对应线程，可以省略掉创建线程和销毁线程的开销，同时操作系统的调度任务因为线程较少（只有<code>node</code>内部实现的一些线程）上下文切换的代价很低。</p><p>经典问题--<strong>雪崩问题</strong>的解决：</p><p>问题描述：服务器在刚启动时，缓存无数据，如果访问量巨大，同一条<code>SQL</code>会被发送到数据库中反复查询，影响性能。</p><p>解决方案：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> events.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EventEmitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态锁，避免反复查询</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;selected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定一个只执行一次名为 selected 的事件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;pending&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// sql</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		db.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SQL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;selected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, res); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发事件,返回查询数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用<code>once</code>将所有请求的回调都压入了事件队列中，利用其只执行一次就会将监视器移除的特点，保证每一个回调函数只会被执行一次。对于相同的 SQL 语句，保证在同一个查询开始到结束的过程中永远只有一次。新到来的相同调用只需在队列中等待数据就绪即可，一旦查询到结果，得到的结果就可以被这些调用共同使用。</p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>基本都是参考《深入浅出 NodeJS》这本书的并夹带了一些自己的理解，如果我理解有误的话，欢迎友善指出🎉</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>《深入浅出 NodeJS》</li></ul>`,17))])}const b=l(n,[["render",Q]]);export{y as __pageData,b as default};
